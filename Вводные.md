## Разработка системы 2FA на Go

### Архитектура решения
Система состоит из:
- API-сервера на Go
- базы данных для хранения пользователей, устройств и сессий
- RADIUS-сервера для интеграции с VPN/NGFW
- личного кабинета пользователей
- административной панели

### Основные компоненты
#### 1. Аутентификация и авторизация
Первый фактор — стандартные логин/пароль.

Второй фактор:
- PUSH-уведомления
- OTP-коды
- звонки

RADIUS-протокол для интеграции с:
- OpenVPN
- Cisco AnyConnect
- Checkpoint
- FortiGate
- UserGate
- MikroTik
- Palo Alto

#### 2. Защищаемые протоколы
- VPN-подключения через RADIUS
- RDP/LDAP/SSH аутентификация
- почтовый доступ: Outlook Web Access, ActiveSync
- ADFS-интеграция
- Windows-аутентификация

### Функциональные модули
#### Модуль пользователей
- синхронизация с AD
- групповая политика доступа
- регистрация через Email/SMS/ссылки-приглашения

#### Личный кабинет
- управление устройствами
- настройка 2FA
- контроль почтовых клиентов
- история входов

#### Админ-панель
- управление пользователями и группами
- аудит и журналирование
- политики доступа и 2FA
- мониторинг активности

### Техническая реализация
#### Базовые зависимости
```go
package main

import (
    "github.com/pquerna/otp/totp" // OTP
    "gopkg.in/ldap.v2"            // работа с AD
    "github.com/golang-jwt/jwt"   // токены
    "github.com/gorilla/mux"      // веб-фреймворк
)
```

#### Основные эндпоинты API
- `/api/v1/auth/` — аутентификация
- `/api/v1/users/` — управление пользователями
- `/api/v1/radius/` — RADIUS-интеграция
- `/api/v1/devices/` — управление устройствами

#### Схема БД (таблицы, связи, индексы)
Нотации:
- ключи `PK/FK`, поля `NOT NULL` по умолчанию
- `id` — UUID v4
- таймстемпы в UTC

**users**
- поля: `id PK`, `username UNIQUE`, `email UNIQUE`, `phone UNIQUE`, `status`, `password_hash`, `ad_dn`, `created_at`, `updated_at`
- индексы: `idx_users_status`, `idx_users_ad_dn`
- ограничения: `status IN ('active','disabled','locked','pending')`

**devices**
- поля: `id PK`, `user_id FK users`, `type`, `name`, `status`, `last_seen_at`, `created_at`
- индексы: `idx_devices_user`, `idx_devices_type`
- ограничения: `type IN ('mobile','hardware','email','sms')`, `status IN ('active','disabled')`
- FK: `user_id -> users.id ON DELETE CASCADE`

**user_sessions**
- поля: `id PK`, `user_id FK users`, `refresh_token_hash UNIQUE`, `ip`, `user_agent`, `expires_at`, `created_at`, `revoked_at`
- индексы: `idx_sessions_user`, `idx_sessions_expires`
- ограничения: `expires_at > created_at`
- FK: `user_id -> users.id ON DELETE CASCADE`

**otp_secrets**
- поля: `id PK`, `user_id FK users`, `secret`, `issuer`, `digits`, `period`, `enabled`, `created_at`
- индексы: `idx_otp_user`
- ограничения: `digits IN (6,8)`, `period IN (30,60)`
- FK: `user_id -> users.id ON DELETE CASCADE`

**push_tokens**
- поля: `id PK`, `user_id FK users`, `device_id FK devices`, `token`, `provider`, `enabled`, `created_at`
- индексы: `idx_push_user`, `idx_push_device`
- ограничения: `provider IN ('apns','fcm','hms')`
- FK: `user_id -> users.id ON DELETE CASCADE`, `device_id -> devices.id ON DELETE SET NULL`

**call_requests**
- поля: `id PK`, `user_id FK users`, `phone`, `status`, `provider`, `created_at`, `answered_at`
- индексы: `idx_calls_user`, `idx_calls_status`
- ограничения: `status IN ('created','delivered','answered','failed','expired')`
- FK: `user_id -> users.id ON DELETE CASCADE`

**groups**
- поля: `id PK`, `name UNIQUE`, `description`, `created_at`

**user_groups**
- поля: `user_id FK users`, `group_id FK groups`, `created_at`
- индексы: `idx_user_groups_group`
- ограничения: `PRIMARY KEY (user_id, group_id)`
- FK: `user_id -> users.id ON DELETE CASCADE`, `group_id -> groups.id ON DELETE CASCADE`

**policies**
- поля: `id PK`, `name UNIQUE`, `priority`, `status`, `created_at`
- индексы: `idx_policies_priority`
- ограничения: `status IN ('active','disabled')`, `priority >= 0`

**policy_rules**
- поля: `id PK`, `policy_id FK policies`, `rule_type`, `rule_value`, `created_at`
- индексы: `idx_policy_rules_policy`
- ограничения: `rule_type IN ('group','user','ip','time','channel','method')`
- FK: `policy_id -> policies.id ON DELETE CASCADE`

**radius_clients**
- поля: `id PK`, `name UNIQUE`, `ip UNIQUE`, `secret`, `enabled`, `created_at`
- индексы: `idx_radius_clients_enabled`

**login_history**
- поля: `id PK`, `user_id FK users`, `channel`, `result`, `ip`, `device_id FK devices`, `created_at`
- индексы: `idx_login_user`, `idx_login_created`, `idx_login_result`
- ограничения: `channel IN ('web','mobile','vpn','mail','rdp','ssh')`, `result IN ('success','deny','timeout','error')`
- FK: `user_id -> users.id ON DELETE SET NULL`, `device_id -> devices.id ON DELETE SET NULL`

**audit_events**
- поля: `id PK`, `actor_user_id FK users`, `action`, `entity_type`, `entity_id`, `payload`, `ip`, `created_at`
- индексы: `idx_audit_actor`, `idx_audit_entity`, `idx_audit_created`
- ограничения: `entity_type IN ('user','device','group','policy','radius_client','session')`
- FK: `actor_user_id -> users.id ON DELETE SET NULL`

**ad_sync_state**
- поля: `id PK`, `last_sync_at`, `status`, `details`
- ограничения: `status IN ('idle','running','failed','completed')`

Связи:
- `users 1—N devices`
- `users 1—N user_sessions`
- `users 1—N otp_secrets`
- `users 1—N push_tokens`
- `users 1—N call_requests`
- `users N—N groups` через `user_groups`
- `policies 1—N policy_rules`
- `users 1—N login_history`
- `users 1—N audit_events` (actor)

#### Потоки аутентификации
**API (web/mobile):**
1) Клиент отправляет `username/password` в `/api/v1/auth/login`.
2) Сервер проверяет первый фактор (локально или через AD/LDAP).
3) Сервер инициирует 2FA: PUSH/OTP/звонок.
4) Клиент подтверждает 2FA: `/api/v1/auth/verify`.
5) Сервер выдает `access_token` и `refresh_token`.
6) Обновление токенов: `/api/v1/auth/refresh`.
7) Выход и отзыв сессии: `/api/v1/auth/logout`.

**RADIUS (VPN/NGFW):**
1) RADIUS-клиент шлет `Access-Request`.
2) Сервер проверяет `radius_clients` (IP/secret).
3) Первый фактор: AD/LDAP или локальная БД.
4) Инициация 2FA (PUSH/OTP/звонок).
5) Ожидание подтверждения в пределах таймаута.
6) Ответ `Access-Accept` или `Access-Reject`.
7) Запись в `login_history` и аудит.

#### Статусы и таймауты 2FA
**Статусы проверки 2FA:**
- `created` — запрос создан, ожидает отправки
- `sent` — отправлено пользователю
- `pending` — ожидается подтверждение
- `approved` — подтверждено
- `denied` — отклонено
- `expired` — истек таймаут
- `failed` — техническая ошибка

**Рекомендованные таймауты:**
- OTP: `60–120s` (период окна валидации)
- PUSH: `60–90s` ожидание ответа
- звонок: `90–120s` ожидание подтверждения
- RADIUS: общий таймаут `30–45s` (с повтором 1–2 раза)
- API-сессия подтверждения: `5–10 min`

**Ограничения на попытки:**
- максимум `5` попыток за `5 min` на пользователя
- блокировка на `10–15 min` после превышения лимита

#### Пример обработки RADIUS (псевдокод)
```go
func handleRadiusPacket(pkt *RadiusPacket) RadiusResponse {
    username := pkt.Username

    // 1) Первый фактор через AD/LDAP
    if !checkADCredentials(username, pkt.Password) {
        return AccessReject()
    }

    // 2) Запрос второго фактора
    sendSecondFactorRequest(username)

    // 3) Проверка результата второго фактора
    if !checkSecondFactor(username) {
        return AccessReject()
    }

    return AccessAccept()
}
```

#### Каркас сервисов и DTO
Слой сервисов:
```go
type AuthService interface {
    Login(ctx context.Context, req LoginRequest) (LoginResponse, error)
    VerifySecondFactor(ctx context.Context, req VerifyRequest) (TokenPair, error)
    Refresh(ctx context.Context, req RefreshRequest) (TokenPair, error)
    Logout(ctx context.Context, sessionID string) error
}

type UserService interface {
    Get(ctx context.Context, id string) (UserDTO, error)
    Create(ctx context.Context, req CreateUserRequest) (UserDTO, error)
    Update(ctx context.Context, id string, req UpdateUserRequest) (UserDTO, error)
    Disable(ctx context.Context, id string) error
}

type RadiusService interface {
    HandleAccessRequest(ctx context.Context, req RadiusRequest) (RadiusResponse, error)
}
```

DTO (пример):
```go
type LoginRequest struct {
    Username string
    Password string
    Channel  string // web, mobile, vpn
}

type VerifyRequest struct {
    UserID     string
    Method     string // push, otp, call
    Code       string
    Challenge  string
}

type TokenPair struct {
    AccessToken  string
    RefreshToken string
    ExpiresIn    int64
}

type UserDTO struct {
    ID       string
    Username string
    Email    string
    Phone    string
    Status   string
}
```

#### Структура пакетов Go-проекта
```
/cmd
  /api-server
  /radius-server
/internal
  /config
  /api
    /handlers
    /middlewares
    /router
  /auth
    /service
    /otp
    /push
    /call
  /radius
    /service
    /protocol
  /users
    /service
    /repository
  /devices
    /service
    /repository
  /policies
    /service
    /repository
  /audit
    /service
    /repository
  /ad
    /sync
    /client
  /storage
    /postgres
    /migrations
  /dto
  /models
  /utils
/pkg
  /logger
  /metrics
  /validator
/configs
/migrations
/docs
```

#### DDL-скрипты (PostgreSQL)
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  username TEXT NOT NULL UNIQUE,
  email TEXT UNIQUE,
  phone TEXT UNIQUE,
  status TEXT NOT NULL CHECK (status IN ('active','disabled','locked','pending')),
  password_hash TEXT,
  ad_dn TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_ad_dn ON users(ad_dn);

CREATE TABLE devices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('mobile','hardware','email','sms')),
  name TEXT,
  status TEXT NOT NULL CHECK (status IN ('active','disabled')),
  last_seen_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_devices_user ON devices(user_id);
CREATE INDEX idx_devices_type ON devices(type);

CREATE TABLE user_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  refresh_token_hash TEXT NOT NULL UNIQUE,
  ip TEXT,
  user_agent TEXT,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  revoked_at TIMESTAMPTZ,
  CHECK (expires_at > created_at)
);
CREATE INDEX idx_sessions_user ON user_sessions(user_id);
CREATE INDEX idx_sessions_expires ON user_sessions(expires_at);

CREATE TABLE otp_secrets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  secret TEXT NOT NULL,
  issuer TEXT,
  digits INT NOT NULL CHECK (digits IN (6,8)),
  period INT NOT NULL CHECK (period IN (30,60)),
  enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_otp_user ON otp_secrets(user_id);

CREATE TABLE push_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  device_id UUID REFERENCES devices(id) ON DELETE SET NULL,
  token TEXT NOT NULL,
  provider TEXT NOT NULL CHECK (provider IN ('apns','fcm','hms')),
  enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_push_user ON push_tokens(user_id);
CREATE INDEX idx_push_device ON push_tokens(device_id);

CREATE TABLE call_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  phone TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('created','delivered','answered','failed','expired')),
  provider TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  answered_at TIMESTAMPTZ
);
CREATE INDEX idx_calls_user ON call_requests(user_id);
CREATE INDEX idx_calls_status ON call_requests(status);

CREATE TABLE groups (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE user_groups (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, group_id)
);
CREATE INDEX idx_user_groups_group ON user_groups(group_id);

CREATE TABLE policies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL UNIQUE,
  priority INT NOT NULL CHECK (priority >= 0),
  status TEXT NOT NULL CHECK (status IN ('active','disabled')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_policies_priority ON policies(priority);

CREATE TABLE policy_rules (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  policy_id UUID NOT NULL REFERENCES policies(id) ON DELETE CASCADE,
  rule_type TEXT NOT NULL CHECK (rule_type IN ('group','user','ip','time','channel','method')),
  rule_value TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_policy_rules_policy ON policy_rules(policy_id);

CREATE TABLE radius_clients (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL UNIQUE,
  ip INET NOT NULL UNIQUE,
  secret TEXT NOT NULL,
  enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_radius_clients_enabled ON radius_clients(enabled);

CREATE TABLE login_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  channel TEXT NOT NULL CHECK (channel IN ('web','mobile','vpn','mail','rdp','ssh')),
  result TEXT NOT NULL CHECK (result IN ('success','deny','timeout','error')),
  ip TEXT,
  device_id UUID REFERENCES devices(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_login_user ON login_history(user_id);
CREATE INDEX idx_login_created ON login_history(created_at);
CREATE INDEX idx_login_result ON login_history(result);

CREATE TABLE radius_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  client_id UUID REFERENCES radius_clients(id) ON DELETE SET NULL,
  username TEXT,
  nas_ip INET,
  result TEXT NOT NULL CHECK (result IN ('accept','reject','timeout','error')),
  request_id TEXT,
  request_attrs JSONB,
  response_attrs JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_radius_requests_client ON radius_requests(client_id);
CREATE INDEX idx_radius_requests_user ON radius_requests(username);
CREATE INDEX idx_radius_requests_created ON radius_requests(created_at);

CREATE TABLE audit_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  actor_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  action TEXT NOT NULL,
  entity_type TEXT NOT NULL CHECK (entity_type IN ('user','device','group','policy','radius_client','session')),
  entity_id UUID,
  payload JSONB,
  ip TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_audit_actor ON audit_events(actor_user_id);
CREATE INDEX idx_audit_entity ON audit_events(entity_type, entity_id);
CREATE INDEX idx_audit_created ON audit_events(created_at);

CREATE TABLE ad_sync_state (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  last_sync_at TIMESTAMPTZ,
  status TEXT NOT NULL CHECK (status IN ('idle','running','failed','completed')),
  details TEXT
);
```

#### Enums и константы (Go)
```go
package models

type UserStatus string
const (
    UserActive   UserStatus = "active"
    UserDisabled UserStatus = "disabled"
    UserLocked   UserStatus = "locked"
    UserPending  UserStatus = "pending"
)

type DeviceType string
const (
    DeviceMobile   DeviceType = "mobile"
    DeviceHardware DeviceType = "hardware"
    DeviceEmail    DeviceType = "email"
    DeviceSMS      DeviceType = "sms"
)

type SecondFactorMethod string
const (
    MethodPush SecondFactorMethod = "push"
    MethodOTP  SecondFactorMethod = "otp"
    MethodCall SecondFactorMethod = "call"
)

type AuthResult string
const (
    AuthSuccess AuthResult = "success"
    AuthDeny    AuthResult = "deny"
    AuthTimeout AuthResult = "timeout"
    AuthError   AuthResult = "error"
)

type AuthChannel string
const (
    ChannelWeb    AuthChannel = "web"
    ChannelMobile AuthChannel = "mobile"
    ChannelVPN    AuthChannel = "vpn"
    ChannelMail   AuthChannel = "mail"
    ChannelRDP    AuthChannel = "rdp"
    ChannelSSH    AuthChannel = "ssh"
)

type RadiusResult string
const (
    RadiusAccept  RadiusResult = "accept"
    RadiusReject  RadiusResult = "reject"
    RadiusTimeout RadiusResult = "timeout"
    RadiusError   RadiusResult = "error"
)

type PolicyStatus string
const (
    PolicyActive   PolicyStatus = "active"
    PolicyDisabled PolicyStatus = "disabled"
)

type PolicyRuleType string
const (
    RuleGroup   PolicyRuleType = "group"
    RuleUser    PolicyRuleType = "user"
    RuleIP      PolicyRuleType = "ip"
    RuleTime    PolicyRuleType = "time"
    RuleChannel PolicyRuleType = "channel"
    RuleMethod  PolicyRuleType = "method"
)

type AuditEntityType string
const (
    AuditEntityUser         AuditEntityType = "user"
    AuditEntityDevice       AuditEntityType = "device"
    AuditEntityGroup        AuditEntityType = "group"
    AuditEntityPolicy       AuditEntityType = "policy"
    AuditEntityRadiusClient AuditEntityType = "radius_client"
    AuditEntitySession      AuditEntityType = "session"
)

type AuditAction string
const (
    AuditCreate  AuditAction = "create"
    AuditUpdate  AuditAction = "update"
    AuditDelete  AuditAction = "delete"
    AuditLogin   AuditAction = "login"
    AuditLogout  AuditAction = "logout"
    AuditEnable  AuditAction = "enable"
    AuditDisable AuditAction = "disable"
)

const (
    OTPWindowSeconds      = 90
    PushTimeoutSeconds    = 90
    CallTimeoutSeconds    = 120
    MaxAttemptsPerWindow  = 5
    AttemptsWindowSeconds = 300
    LockoutSeconds        = 900
)
```

#### Модели и интерфейсы репозиториев
```go
package models

import "time"

type User struct {
    ID           string
    Username     string
    Email        string
    Phone        string
    Status       UserStatus
    PasswordHash string
    AdDN         string
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type Device struct {
    ID         string
    UserID     string
    Type       DeviceType
    Name       string
    Status     string
    LastSeenAt *time.Time
    CreatedAt  time.Time
}

type UserSession struct {
    ID               string
    UserID           string
    RefreshTokenHash string
    IP               string
    UserAgent        string
    ExpiresAt        time.Time
    CreatedAt        time.Time
    RevokedAt        *time.Time
}

type Policy struct {
    ID        string
    Name      string
    Priority  int
    Status    PolicyStatus
    CreatedAt time.Time
}

type PolicyRule struct {
    ID        string
    PolicyID  string
    RuleType  PolicyRuleType
    RuleValue string
    CreatedAt time.Time
}

type RadiusClient struct {
    ID        string
    Name      string
    IP        string
    Secret    string
    Enabled   bool
    CreatedAt time.Time
}

type AuditEvent struct {
    ID         string
    ActorUserID string
    Action     AuditAction
    EntityType AuditEntityType
    EntityID   string
    Payload    string
    IP         string
    CreatedAt  time.Time
}

type LoginHistory struct {
    ID        string
    UserID    string
    Channel   AuthChannel
    Result    AuthResult
    IP        string
    DeviceID  string
    CreatedAt time.Time
}

type RadiusRequest struct {
    ID           string
    ClientID     string
    Username     string
    NASIP        string
    Result       RadiusResult
    RequestID    string
    RequestAttrs string
    ResponseAttrs string
    CreatedAt    time.Time
}
```

```go
package repository

import (
    "context"
    "time"
    "example.com/project/internal/models"
)

type UserRepository interface {
    GetByID(ctx context.Context, id string) (*models.User, error)
    GetByUsername(ctx context.Context, username string) (*models.User, error)
    Create(ctx context.Context, u *models.User) error
    Update(ctx context.Context, u *models.User) error
    SetStatus(ctx context.Context, id string, status models.UserStatus) error
}

type SessionRepository interface {
    Create(ctx context.Context, s *models.UserSession) error
    Revoke(ctx context.Context, id string, revokedAt time.Time) error
    GetByRefreshHash(ctx context.Context, hash string) (*models.UserSession, error)
}

type DeviceRepository interface {
    ListByUser(ctx context.Context, userID string) ([]models.Device, error)
    Upsert(ctx context.Context, d *models.Device) error
    Disable(ctx context.Context, id string) error
}

type PolicyRepository interface {
    GetByID(ctx context.Context, id string) (*models.Policy, error)
    List(ctx context.Context) ([]models.Policy, error)
    Create(ctx context.Context, p *models.Policy) error
    Update(ctx context.Context, p *models.Policy) error
    SetStatus(ctx context.Context, id string, status string) error
}

type PolicyRuleRepository interface {
    ListByPolicy(ctx context.Context, policyID string) ([]models.PolicyRule, error)
    Create(ctx context.Context, r *models.PolicyRule) error
    Delete(ctx context.Context, id string) error
}

type RadiusClientRepository interface {
    GetByIP(ctx context.Context, ip string) (*models.RadiusClient, error)
    List(ctx context.Context) ([]models.RadiusClient, error)
    Create(ctx context.Context, c *models.RadiusClient) error
    Update(ctx context.Context, c *models.RadiusClient) error
    SetEnabled(ctx context.Context, id string, enabled bool) error
}

type AuditRepository interface {
    Create(ctx context.Context, e *models.AuditEvent) error
    ListByActor(ctx context.Context, actorUserID string, limit int) ([]models.AuditEvent, error)
    ListByEntity(ctx context.Context, entityType, entityID string, limit int) ([]models.AuditEvent, error)
}

type LoginHistoryRepository interface {
    Create(ctx context.Context, h *models.LoginHistory) error
    ListByUser(ctx context.Context, userID string, limit int) ([]models.LoginHistory, error)
    ListByChannel(ctx context.Context, channel string, limit int) ([]models.LoginHistory, error)
    ListByPeriod(ctx context.Context, from, to time.Time, limit int) ([]models.LoginHistory, error)
}

type RadiusRequestRepository interface {
    Create(ctx context.Context, r *models.RadiusRequest) error
    ListByClient(ctx context.Context, clientID string, limit int) ([]models.RadiusRequest, error)
    ListByUser(ctx context.Context, username string, limit int) ([]models.RadiusRequest, error)
    UpdateResult(ctx context.Context, id string, result string) error
}
```

#### DTO для админ‑панели и API
```go
package dto

import (
    "time"
    "example.com/project/internal/models"
)

type AdminUserListItem struct {
    ID       string
    Username string
    Email    string
    Phone    string
    Status   models.UserStatus
}

type AdminPolicyDTO struct {
    ID       string
    Name     string
    Priority int
    Status   models.PolicyStatus
    Rules    []PolicyRuleDTO
}

type PolicyRuleDTO struct {
    ID       string
    Type     models.PolicyRuleType
    Value    string
}

type AdminRadiusClientDTO struct {
    ID      string
    Name    string
    IP      string
    Enabled bool
}

type AdminAuditEventDTO struct {
    ID         string
    ActorUserID string
    Action     models.AuditAction
    EntityType models.AuditEntityType
    EntityID   string
    IP         string
    CreatedAt  time.Time
}

type LoginHistoryDTO struct {
    ID        string
    UserID    string
    Channel   models.AuthChannel
    Result    models.AuthResult
    IP        string
    DeviceID  string
    CreatedAt time.Time
}

type RadiusRequestDTO struct {
    ID        string
    ClientID  string
    Username  string
    NASIP     string
    Result    models.RadiusResult
    CreatedAt time.Time
}

type PageRequest struct {
    Limit     int
    Offset    int
    SortBy    string
    SortOrder string // asc|desc
}

type PageResponse struct {
    Total  int
    Limit  int
    Offset int
}

type AdminUserFilter struct {
    Query  string
    Status models.UserStatus
    GroupID string
}

type AdminPolicyFilter struct {
    Status models.PolicyStatus
}

type AdminAuditFilter struct {
    ActorUserID string
    EntityType  models.AuditEntityType
    Action      models.AuditAction
    From        time.Time
    To          time.Time
}

type AdminLoginHistoryFilter struct {
    UserID  string
    Channel models.AuthChannel
    Result  models.AuthResult
    From    time.Time
    To      time.Time
}

type AdminRadiusRequestFilter struct {
    ClientID string
    Username string
    Result   models.RadiusResult
    From     time.Time
    To       time.Time
}

type AdminUserListRequest struct {
    Page   PageRequest
    Filter AdminUserFilter
}

type AdminUserListResponse struct {
    Items []AdminUserListItem
    Page  PageResponse
}

type AdminAuditListRequest struct {
    Page   PageRequest
    Filter AdminAuditFilter
}

type AdminAuditListResponse struct {
    Items []AdminAuditEventDTO
    Page  PageResponse
}

type AdminLoginHistoryListRequest struct {
    Page   PageRequest
    Filter AdminLoginHistoryFilter
}

type AdminLoginHistoryListResponse struct {
    Items []LoginHistoryDTO
    Page  PageResponse
}

type AdminRadiusRequestListRequest struct {
    Page   PageRequest
    Filter AdminRadiusRequestFilter
}

type AdminRadiusRequestListResponse struct {
    Items []RadiusRequestDTO
    Page  PageResponse
}
```

#### Схемы API‑эндпоинтов для админ‑панели
Базовый путь: `/api/v1/admin`

**Пользователи**
- `GET /users` — список пользователей (фильтры и пагинация: `AdminUserListRequest`)
- `GET /users/{id}` — карточка пользователя
- `POST /users` — создать пользователя
- `PUT /users/{id}` — обновить пользователя
- `POST /users/{id}/status` — смена статуса (enable/disable/lock)
- `GET /users/{id}/devices` — устройства пользователя
- `GET /users/{id}/logins` — история входов пользователя

**Группы**
- `GET /groups` — список групп
- `POST /groups` — создать группу
- `PUT /groups/{id}` — обновить группу
- `POST /groups/{id}/members` — добавить участников
- `DELETE /groups/{id}/members/{userId}` — удалить участника

**Политики**
- `GET /policies` — список политик
- `GET /policies/{id}` — карточка политики
- `POST /policies` — создать политику
- `PUT /policies/{id}` — обновить политику
- `POST /policies/{id}/status` — включить/выключить
- `POST /policies/{id}/rules` — добавить правило
- `DELETE /policies/{id}/rules/{ruleId}` — удалить правило

**RADIUS‑клиенты**
- `GET /radius/clients` — список клиентов
- `POST /radius/clients` — создать клиента
- `PUT /radius/clients/{id}` — обновить клиента
- `POST /radius/clients/{id}/enabled` — включить/выключить
- `GET /radius/requests` — журнал RADIUS‑запросов (фильтры и пагинация)

**Аудит и история**
- `GET /audit/events` — аудит (фильтры и пагинация: `AdminAuditListRequest`)
- `GET /logins` — история входов (фильтры и пагинация: `AdminLoginHistoryListRequest`)

### Требования к инфраструктуре
- ОС: Linux/Windows
- память: минимум 8GB RAM
- диск: минимум 200GB SSD
- процессор: 4 ядра и выше
- сетевые порты: TCP 443 (HTTPS), UDP 1812/1813 (RADIUS)

### Дополнительные возможности
- массовая регистрация через CSV
- журналирование событий
- администрирование групп
- мониторинг активности
- API для интеграции с другими системами

### Рекомендации по безопасности
- шифрование данных в БД
- HTTPS для всех соединений
- rate limiting для защиты от брутфорса
- 2FA для администраторов
- резервное копирование данных

### Требования к логированию и аудиту
- единый `request_id`/`correlation_id` на входе, проброс во все сервисы
- уровни: `debug`, `info`, `warn`, `error`
- обязательные поля: `timestamp`, `level`, `service`, `request_id`, `user_id`, `ip`, `action`, `result`
- журналирование попыток входа (успех/ошибка/причина)
- аудит админ-действий: кто, что, когда, над чем
- хранение логов не менее 180 дней (настройка)
- маскирование чувствительных данных (пароли, OTP, токены)
- отдельный канал для безопасности (SIEM/ELK/Graylog)

### Что потребуется для полноценной реализации
- схема БД: пользователи, устройства, сессии, политики
- система уведомлений (PUSH/SMS/звонки)
- интеграционные адаптеры для различных протоколов
- фронтенд для личного кабинета и админ-панели
